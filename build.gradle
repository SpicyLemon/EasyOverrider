plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'java-library'
    // Publishing
    id 'com.jfrog.bintray' version '1.8.0'
    id 'maven-publish'
    // Git stuff
    id 'org.ajoberstar.grgit' version '3.1.1'
    // Versioning
    id 'org.ajoberstar.reckon' version '0.11.0'
}

import org.gradle.internal.logging.text.StyledTextOutputFactory
import static org.gradle.internal.logging.text.StyledTextOutput.Style

description = 'An easier way to override equals, hashCode, and toString in Java objects.'

def githubRepoUrl = 'https://github.com/SpicyLemon/EasyOverrider'
def javadocDir = 'docs'

// If no tasks are listed, list all the tasks.
defaultTasks 'tasks'

repositories {
    // Use jcenter for resolving dependencies.
    jcenter()
}

dependencies {
    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}

compileJava {
    options.compilerArgs += ['-Xdiags:verbose', '-Xlint:unchecked']
}

// Some tasks to make it easier to set the reckon stage and scope parameters.
// Default stage is snapshot, default scope is patch, so we only need tasks for the other options.
// These tasks don't actually have any actions. Rather, their existence in the list of tasks is looked for
//  while setting up all the reckon stuff.
task finalVersion {
    group = PublishingPlugin.PUBLISH_TASK_GROUP
    description = 'Sets the reckon.stage to final'
}
task majorUpdate {
    group = PublishingPlugin.PUBLISH_TASK_GROUP
    description = 'Sets the reckon.scope to major'
}
task minorUpdate {
    group = PublishingPlugin.PUBLISH_TASK_GROUP
    description = 'Sets the reckon.scope to minor'
}

// And set up all the reckon stuff
reckon {
    scopeFromProp()
    if (gradle.startParameter.taskNames.contains('majorUpdate')) {
        setIfNotSet('reckon.scope', 'major')
    } else if (gradle.startParameter.taskNames.contains('minorUpdate')) {
        setIfNotSet('reckon.scope', 'minor')
    } else {
        setIfNotSet('reckon.scope', 'patch')
    }
    snapshotFromProp()
    //sample usage: ./gradlew reckonTagCreate -Preckon.stage=final
    //          or: ./gradlew reckonTagCreate -Preckon.stage=final -Preckon.scope=minor
    if (gradle.startParameter.taskNames.contains('finalVersion') || gradle.startParameter.taskNames.contains('release')) {
        setIfNotSet('reckon.stage', 'final')
    }
}

// Enhance the output for unit test failures
tasks.withType(Test) { 
  testLogging {
    exceptionFormat 'full'
    events 'failed'
    showStandardStreams true
  }
}
test {
    // Do a cleanTest first so that test always run when asked for
    dependsOn 'cleanTest'
    
    // Set some coloring stuff up
    System.setProperty('org.gradle.color.failure', 'RED')
    System.setProperty('org.gradle.color.progressstatus', 'YELLOW')
    System.setProperty('org.gradle.color.success', 'GREEN')
    def out = services.get(StyledTextOutputFactory).create('colored-test-output')
    out.style(Style.Normal)

    // Print the Test Suite name before running its tests.
    beforeSuite { suite ->
        if (suite.name.startsWith('Test Run') || suite.name.startsWith('Gradle Worker')) return
        out.println("\n" + suite.name)
    }
    // For each test, output using the appropriate color include the test name and the result.
    afterTest { descriptor, result ->
        def style
        if (result.failedTestCount > 0) style = Style.Failure
        else if (result.skippedTestCount > 0) style = Style.ProgressStatus
        else style = Style.Success
        out.text('  ').withStyle(style).println((style == Style.Success ? '    ' + 'PASSED'
                                                : style == Style.ProgressStatus ? '  ' + 'SKIPPED'
                                                : 'FAILED') + '  ' + descriptor.name)
    }
    // When all done, output a summary.
    afterSuite { desc, result ->
        if (!desc.parent) { // will match the outermost suite
            out.println("Results: ${result.resultType} " +
                    "(${result.testCount} tests, " +
                    "${result.successfulTestCount} successes, " +
                    "${result.failedTestCount} failures, " +
                    "${result.skippedTestCount} skipped)")
        }
    }
}

task commitJavadoc {
    description "Commits the javadoc directory if possible and needed."
    doLast {
        gitCommitDir(javadocDir)
    }
}

// Change the destination directory for javadocs so that gitlab can automatically publish them.
// Also provide links to the main java stuff which also makes the javadoc use the simple names for them.
// Lastly, once the new files have been generated do a commit for them (if we're clean right now).
tasks.withType(Javadoc) {
    destinationDir = file('' + rootDir + '/' + javadocDir + '/')
    options {
        links('https://docs.oracle.com/javase/8/docs/api')
    }
    finalizedBy commitJavadoc
}

// Create a sources jar when we build
task sourcesJar(type: Jar) {
    group = JavaBasePlugin.BUILD_TASK_NAME
    description = 'Assembles a jar archive containing the source.'
    dependsOn 'classes'
    archiveClassifier = 'source'
    doLast {
        from sourceSets.main.allJava
    }
}

// Create a javadoc jar when we build
task javadocJar(type: Jar) {
    group = JavaBasePlugin.BUILD_TASK_NAME
    description = 'Assembles a jar archive containing the javadoc.'
    dependsOn 'javadoc', 'classes'
    archiveClassifier = 'javadoc'
    doLast {
        from javadoc.destinationDir
    }
}

assemble.mustRunAfter clean
test.mustRunAfter assemble
javadoc.mustRunAfter assemble
task release {
    group = PublishingPlugin.PUBLISH_TASK_GROUP
    description = 'Cleans, builds, tests, updates javadoc, tags, pushes and publishes.'
    dependsOn clean, assemble, test, javadoc
    finalizedBy reckonTagPush, bintrayUpload
}

def pomConfig = {
    licenses {
        license {
            name 'MIT'
            url githubRepoUrl + '/blob/master/LICENSE'
            distribution 'repo'
        }
    }
    developers {
        developer {
            id 'spicylemon'
            name 'Daniel Wedul'
            email 'easyoverrider@wedul.com'
        }
    }
    scm {
        url githubRepoUrl
    }
}

// Add the sources and javadoc jars as artifacts to publish
project.afterEvaluate {
    publishing {
        publications {
            bintrayPublication(MavenPublication) {
                from components.java
                artifactId 'easyOverrider'
                groupId 'spicylemon'
                artifact sourcesJar
                artifact javadocJar
                version "$project.version"
                pom.withXml {
                    def root = asNode()
                    root.appendNode('description', description)
                    root.appendNode('name', 'easyOverrider')
                    root.appendNode('url', githubRepoUrl)
                    root.children().last() + pomConfig
                }
            }
        }
    }
}

bintray {
    user = resolveProperty('BINTRAY_USER', 'bintray.user')
    key = resolveProperty('BINTRAY_KEY', 'bintray.key')
    publications = ['bintrayPublication']
    publish = true

    pkg {
        repo = 'maven'
        name = 'easyOverrider'
        userOrg = resolveProperty('BINTRAY_ORG', 'bintray.org')
        desc = description
        websiteUrl = githubRepoUrl
        issueTrackerUrl = githubRepoUrl + '/issues'
        vcsUrl = githubRepoUrl
        licenses = ['MIT']
        labels = ['equals', 'hashCode', 'toString', 'override']
        publicDownloadNumbers = true
        githubRepo = 'SpicyLemon/EasyOverrider'
        version {
            name = "$project.version"
            released  = new Date()
            vcsTag = "v$project.version"
            gpg {
                sign = true
                passphrase = resolveProperty('GPG_PASSPHRASE', 'gpg.passphrase')
            }
            //mavenCentralSync {
            //    sync = true
            //    user = resolveProperty('MAVEN_USER', 'maven.user')
            //    password = resolveProperty('MAVEN_PASSWORD', 'maven.password')
            //    close = '1'
            //}
        }
    }
}

String resolveProperty(String envVarKey, String projectPropKey) {
    String propValue = findProperty(projectPropKey)
    return propValue ?: System.getenv()[envVarKey]
}

Void setIfNotSet(String propertyKey, String value) {
    if (!project.hasProperty(propertyKey)) {
        logger.info('Setting property [' + propertyKey + '] to "' + value + '"')
        project.ext.set(propertyKey, value)
    }
}

void gitCommitDir(String dirToCommit) {
    if (!dirToCommit.endsWith('/')) {
        dirToCommit = dirToCommit + '/'
    }
    def status = grgit.status()
    // Only do the commit if there are changes to commit.
    def doCommit = !status.isClean()
    // Only do the commit if there are no changes already staged.
    doCommit = doCommit && status.staged.allChanges.empty
    // Only do the commit if there are no conflicts.
    doCommit = doCommit && status.conflicts.empty
    // Only do the commit if there are unstaged changes in the dirToCommit.
    doCommit = doCommit && status.unstaged.allChanges.any { it.startsWith(dirToCommit) }
    if (doCommit) {
        grgit.add(patterns: [dirToCommit])
        def commit = grgit.commit(message: 'Update javadoc to version ' + project.version)
        println 'Javadoc updates committed: ' + commit.abbreviatedId + ' "' + commit.fullMessage + '"' + "\n"
    }
}
